{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Panda","text":""},{"location":"#what-is-panda","title":"What is Panda?","text":"<p>It's a High performance all-in-one API Gateway.</p>"},{"location":"#where-can-i-find-it","title":"Where can I find it?","text":"<p>https://github.com/pandafolks/panda</p>"},{"location":"#can-i-contribute","title":"Can I contribute?","text":"<p>Of course! Firstly, learn how to contribute.  Next, check out the open issues. </p>"},{"location":"api/","title":"Scala API","text":"<ul> <li>backgroundJobsRegistry module</li> <li>bootstrap module</li> <li>db module</li> <li>gateway module</li> <li>healthCheck module</li> <li>httpClient module</li> <li>loadBalancer module</li> <li>nodesTracker module</li> <li>participant module</li> <li>routes module</li> <li>sequence module</li> <li>user module</li> <li>utils module</li> </ul>"},{"location":"config/","title":"Application Config","text":"<p>This is an example configuration that you can run Panda instances with.  bootstap/src/main/resources/application.conf </p> <pre><code>app-server {\n    # This is a Http4sEmberServerConfig\n    listen-address = \"0.0.0.0\"\n    listen-port = 8080\n    max-connections = 2048\n    idle-timeout = \"60.seconds\"\n    shutdown-timeout = \"30.seconds\"\n}\n\ngateway {\n    load-balancer-algorithm = \"hash\"                # Available: round-robin, random, hash\n    load-balancer-retries = 9                       # Optional as this is only applicable to the hash-based load balancer, other load balancers will discard this configuration and will hit all possible participants in the worst case. The default is 10.\n}\n\ngateway-client {\n    # This is a Http4sEmberClientConfig responsible for configuration of the Http client used only for gateway requests.\n    max-total = 200                                 # Sets the connection pool's total maximum number of idle connections.\n    idle-time-in-pool = \"30.seconds\"                # Sets the connection pool's maximum time a connection can be idle. The timeout starts when a connection is returned the the pool, and reset when it is borrowed.\n    chunk-size = 32768                              # Sets the max `chunkSize` in bytes to read from sockets at a time.\n    max-response-header-size = 4096                 # Sets the max size in bytes to read while parsing response headers.\n    idle-connection-time = \"20.seconds\"             # Sets the idle timeout on connections. The timeout is reset with each read or write.\n    timeout = \"30.seconds\"                          # Sets the header receive timeout on connections.\n    check-endpoint-identification = \"true\"          # Sets whether or not to force endpoint authentication/verification on the `TLSContext`. Enabled by default. When enabled the server's identity will be checked against the server's certificate during SSL/TLS handshaking. This is important to avoid man-in-the-middle attacks by confirming server identity against their certificate.\n}\n\ninternal-client {\n    # This is a Http4sEmberClientConfig responsible for configuration of the Http client used for any internal communication including healthcheck requests directed to the participants.\n    max-total = 100                                 # Sets the connection pool's total maximum number of idle connections.\n    idle-time-in-pool = \"30.seconds\"                # Sets the connection pool's maximum time a connection can be idle. The timeout starts when a connection is returned the the pool, and reset when it is borrowed.\n    chunk-size = 32768                              # Sets the max `chunkSize` in bytes to read from sockets at a time.\n    max-response-header-size = 4096                 # Sets the max size in bytes to read while parsing response headers.\n    idle-connection-time = \"2.seconds\"              # Sets the idle timeout on connections. The timeout is reset with each read or write.\n    timeout = \"3.seconds\"                           # Sets the header receive timeout on connections.\n    check-endpoint-identification = \"true\"          # Sets whether or not to force endpoint authentication/verification on the `TLSContext`. Enabled by default. When enabled the server's identity will be checked against the server's certificate during SSL/TLS handshaking. This is important to avoid man-in-the-middle attacks by confirming server identity against their certificate.\n}\n\ndb {\n    contact-points = [\n        {\n            host = \"127.0.0.1\"\n            port = 27017\n        },\n    ]\n    username = \"pandaUser\"\n    password = \"pandaPassword\"\n    mode = \"single\"\n\n;     connection-string=\"mongodb+srv://username:password@URL.../panda\"  # The connection string can be used - instead of all the above properties. If both connection-string and contact-points are defined, the connection-string has higher priority.\n\n    db-name = \"panda\"                               # Mandatory name of the database (even if the one in connection-string specified)\n}\n\nconsistency {\n    full-consistency-max-delay = 10                 # The maximum number of seconds after which the instance data will be fully consistent\n}\n\nhealth-check-config {\n    calls-interval = 5                              # The interval between two health checks in seconds\n    number-of-failures-needed-to-react = 3          # The number of allowed failed health checks. After reaching the specified number of fails, the participant will be marked as `Disconnected` and will become `Unhealthy`.\n   # Both of the above values have to be bigger than 0, otherwise, the healthcheck functionality will be turned off.\n\n    participant-is-marked-as-turned-off-delay = 120 # The number of seconds the participant is in the `Unhealthy` state after which the participant will be marked as not working by emitting `TurnedOff` event. If the value is not present or is smaller than 1 the feature is turned off. If turned on, the value is required to be smaller than participant-is-marked-as-removed-delay, otherwise, this setting will be discarded.\n    participant-is-marked-as-removed-delay = 180    # The number of seconds the participant is in the `Unhealthy` state after which the participant will be marked as not working by emitting `Removed` event. If the value is not present or is smaller than 1 the feature is turned off.\n    marked-as-not-working-job-interval = 30         # The number of seconds between the background job calls. The background job is responsible for marking participants as not working in alignment with `participant-is-marked-as-not-working-delay` and `participant-is-marked-as-removed-delay` properties. If the value is not present or is smaller than 1 the default is 30 seconds.\n}\n\nauth-tokens {\n    time-to-live = 3600                             # Number of seconds before authentication tokens expire\n}\n\ninit-user {                                         # If there is no user in the database, a default one will be created\n    username = \"admin\"\n    password = \"admin\"\n}\n\n</code></pre>"},{"location":"contributing/","title":"Contributing to Panda","text":"<p>Hello everyone, this project was created mainly in order to evolve contributors' skills and have fun.  If you don't have either scala or distributed systems experience, that's all right, you can play around here!  We don't have deadlines or any other pressure, so the quality of the solutions is a crucial factor.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>People are expected to follow the Scala Code of Conduct</p>"},{"location":"contributing/#general-workflow","title":"General Workflow","text":"<ul> <li>Make sure you can license your work under Apache 2.0 </li> <li>Pick a ticket from the issues section. Don't hesitate to ask clarifying questions if something is unclear.</li> <li>If you don't have write access to the repository, you should do    your work in a local branch of your own fork and then submit a pull    request. If you do have write access to the repository, never work    directly on master.</li> <li>If you add new methods to services, remember about adding Docs. We are trying to avoid comments inside the code.     However, if some part is more tricky than usual, a short explanation is advised.</li> <li>Once you finish work on your Pull Request, make sure both unit and integration tests are passing:</li> </ul> <pre><code>sbt test\n</code></pre> <pre><code>sbt it:test\n</code></pre> <ul> <li>Make sure the code is formatted with:</li> </ul> <pre><code>sbt scalafmtAll\n</code></pre> <ul> <li>Resolve conflicts with the master branch (if any).</li> <li>Submit a Pull Request.</li> <li>Anyone can comment on a Pull Request, and you are expected to    answer questions or to incorporate feedback.</li> <li>Once the Pull Request is approved, owners will take care of merging.</li> </ul> <p>Despite we try to work along with the issues tracker. Once you see something that may be done in a better way, feel  free to make a Pull Request with improvement.</p>"},{"location":"contributing/#hints","title":"Hints","text":""},{"location":"contributing/#application-entry-point","title":"Application entry point","text":"<p>bootstap/src/main/scala/com/github/pandafolks/panda/bootstrap/App.scala</p>"},{"location":"contributing/#current-authentication-model","title":"Current authentication model","text":"<p><code>http://localhost:8080/api/v1/auth/register</code> endpoint creates a new user. However, it is accessible only to authenticated users. Because of that, new users can be only created by existing ones and that's why <code>application.conf</code> is prefilled with <code>init-user</code>. <code>init-user</code> will be created during app startup only if there is no other user present in the DB.</p>"},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>Inside <code>exampleExternalDependencies</code> directory you could find docker files that runs required components. At this moment panda requires: 1. MongoDB</p>"},{"location":"contributing/#service-examples-used-for-manual-testing","title":"Service examples used for manual testing","text":"<p>As Panda is an API gateway, it is useful to have some services it can communicate to. Inside exampleExternalDependencies/auxiliaryServices directory you may find docker-compose.yml file which runs some simple services. You could register them inside Panda by running registerInsidePanda.sh script. </p>"},{"location":"contributing/#managing-dependencies","title":"Managing dependencies","text":"<p>Panda provides <code>Makefile</code> file for managing project dependencies and tasks in the easy way. To see list of useful  commands run this in the repository root:</p> <pre><code>make help\n</code></pre>"},{"location":"contributing/#creating-executable-jar","title":"Creating executable jar","text":"<pre><code>sbt assembly\n</code></pre> <p>You would find <code>panda.jar</code> inside your <code>/target/scala-2.13</code> directory. You can run it with <code>java -jar panda.jar</code>.</p>"},{"location":"contributing/#using-your-own-config-file","title":"Using your own config file","text":"<p>By default, Panda will use application.conf config from bootstap/src/main/resources.  Feel free to create your own config, you could use it inside panda by adding VM option: </p> <pre><code>-Dconfig.resource=application.conf\n</code></pre>"},{"location":"documentation/","title":"Documentation","text":"<p>This page is incomplete - work in progress!</p>"},{"location":"documentation/#gateway","title":"Gateway","text":""},{"location":"documentation/#gateway-traffic-logging","title":"Gateway traffic logging","text":"<p>The full logging configuration can be found inside <code>bootstap/src/main/resources/logback.xml</code> file.</p> <p>By default, all gateway traffic is logged out to the <code>gateway_traffic.log</code>. The logs contain both request and response headers. However, they do not contain bodies.</p> <p>If the Panda user wants to send the logs to some remote service, the <code>ch.qos.logback.classic.net.SocketAppender</code> appender can be used. More information can be found at this link.</p>"},{"location":"documentation/#load-balancing","title":"Load Balancing","text":""},{"location":"documentation/#highlights","title":"Highlights","text":"<p>Load balancing inside Panda makes sure to distribute the incoming load across available participants. The flow is as follows:</p> <ol> <li>Recognize the path within the request and decide if it's registered and supported inside Panda.</li> <li>Find a group responsible for a path.</li> <li>Pass the request to the load balancer.</li> <li>Route the request to one of the healthy participants assigned to the found group.</li> <li>Failover to another healthy participant if the previously chosen participant is unreachable.</li> <li>Repeat the 5th step in case of failure. </li> </ol> <p>There are 3 supported load balancing algorithms:</p> <ul> <li>Round robin</li> <li>Random</li> <li>Hash based </li> </ul> <p>All the timeouts for a single call made by load balancers are configurable within the <code>gateway-client</code> config. The important is that the failover mechanism is integrated with the timeouts, so reaching the timeout by the single participant will end up with the failover mechanism passing the request to another participant (and automatically killing the previous request).</p> <p> 'group' might be the (micro)service type</p> <p>'participant' is the single instance of the particular type</p>"},{"location":"documentation/#round-robin-load-balancer","title":"Round robin load balancer","text":"<p>This load balancer passes the requests to the participants in a one-by-one order.</p> <p>In order to avoid the failover mechanism sending requests all the time to the same failing participant (which is the worst-case scenario, where other participants are picked between failing request retry calls), the smart failover is implemented which picks the very first participant according to the Round robin order, but in case of failure retries with the next participant (until tries with all available participants) completely independently of the main order. As a result failover mechanism will never pass a specific request to the same participant more than once.</p> <p>How to configure:</p> <pre><code>gateway {\n    load-balancer-algorithm = \"round-robin\"   # Available: round-robin, random, hash\n }\n</code></pre> <p>Known issue: Expand the RoundRobinLoadBalancerImpl and RandomLoadBalancerImpl capabilities</p>"},{"location":"documentation/#random-load-balancer","title":"Random load balancer","text":"<p>This load balancer passes the requests to the participants by choosing them randomly.</p> <p>In order to avoid the failover mechanism sending requests all the time to the same failing participant (which is possible if failover candidates would be chosen randomly), the smart failover is implemented which generates the randomly shuffled queue of failover candidates that includes a single occurrence of all healthy participants. As a result failover mechanism will never pass a specific request to the same participant more than once and in the worst-case scenario will do that exactly once.</p> <p>How to configure:</p> <pre><code>gateway {\n    load-balancer-algorithm = \"random\"   # Available: round-robin, random, hash\n }\n</code></pre> <p>Note: The load balancer tries to hit all available participants. This is an important feature in the worst-case scenario. However, because of that, the solution is relatively slow. The RandomLoadBalancer should be used only with a small number of participants. In other cases, either the RoundRobinLoadBalancer or HashLoadBalancer should be preferred.</p> <p>Known issue: Expand the RoundRobinLoadBalancerImpl and RandomLoadBalancerImpl capabilities</p>"},{"location":"documentation/#hash-based-load-balancer","title":"Hash based load balancer","text":"<p>This load balancer routes the request to the participant based on either the <code>X-Forwarded-For</code> header (left most value - the origin client) or client IP if the <code>X-Forwarded-For</code> header does not exist. As a result, all requests from a single client are routed to the same participant.</p> <p>Because of the nature of the hashing, the client is stuck to the participant as long as there are no new participants within the group or one of the existing ones does not disappear. However, the implementation is using the consistent hashing approach, and because of that, only a small part of clients will be reassigned to a different participant in case of participants' health changes.</p> <p>If the initially picked participant is unreachable, the failover mechanism will pick the failover candidate fully randomly, without guarantee of not asking the same participant more than once. The number of retries is configurable inside the configuration file. Where 10 is the default number of retries.</p> <p>How to configure:</p> <pre><code>gateway {\n    load-balancer-algorithm = \"hash\"       # Available: round-robin, random, hash\n    load-balancer-retries = 5              # Optional as this is only applicable to the hash-based load balancer, other load balancers will discard this configuration and will hit all possible participants in the worst case\n }\n</code></pre> <p>Note: If the Panda works as a cluster of multiple nodes. The load balancer that stands in front of Panda nodes has to route all requests of a particular client to the same, constant node. This is because the consistent hashing circle is created and kept in memory per Panda node and there is no guarantee of client assignment to a particular participant among Panda nodes (only within a single node).</p>"},{"location":"documentation/#x-forwarded-for-header","title":"X-Forwarded-For header","text":"<p>Every Panda load balancer automatically adds the X-Forwarded-For header and helps you identify the IP address of a client.  Because load balancers intercept traffic between clients and servers, your server access logs contain only the IP address of the load balancer.  To see the IP address of the client, use the X-Forwarded-For request header.  Panda's Load Balancers store the IP address of the client in the X-Forwarded-For request header and passes the header to your server.  If the X-Forwarded-For request header is not included in the request, the load balancer creates one with the client IP address as the request value.  Otherwise, the load balancer appends the client IP address to the existing header and passes the header to your server.  The X-Forwarded-For request header may contain multiple IP addresses that are comma separated.  The left-most address is the client IP where the request was first made. This is followed by any subsequent proxy identifiers, in a chain.</p> <p>The X-Forwarded-For header takes the following form:</p> <pre><code>X-Forwarded-For: client-ip-address\n</code></pre>"},{"location":"documentation/#participants-maintaining-health-checks","title":"Participants maintaining (Health checks)","text":""},{"location":"documentation/#marking-participants-as-turnedoff-andor-removed-if-they-are-unhealthy-for-a-while","title":"Marking Participants as TurnedOff and/or Removed if they are Unhealthy for a while","text":"<p>This feature is part of the healthcheck functionality (not documented yet). The healthcheck functionality maintains the operational state of configured participants. Based on this state, the decision whether the traffic should be routed to the particular participant is made.</p> <p>The healtcheck functionality decides only if the instance is Healthy or Unhealthy and does not mark participants as TurnedOff or Removed on its own. This can be achieved by the separate feature that can be configured via the configuration fie:</p> <pre><code>health-check-config {\n    participant-is-marked-as-turned-off-delay = 120 # The number of seconds the participant is in the `Unhealthy` state after which the participant will be marked as not working by emitting `TurnedOff` event. If the value is not present or is smaller than 1 the feature is turned off. If turned on, the value is required to be smaller than participant-is-marked-as-removed-delay, otherwise, this setting will be discarded.\n    participant-is-marked-as-removed-delay = 180    # The number of seconds the participant is in the `Unhealthy` state after which the participant will be marked as not working by emitting `Removed` event. If the value is not present or is smaller than 1 the feature is turned off.\n    marked-as-not-working-job-interval = 30         # The number of seconds between the background job calls. The background job is responsible for marking participants as not working in alignment with `participant-is-marked-as-not-working-delay` and `participant-is-marked-as-removed-delay` properties. If the value is not present or is smaller than 1 the default is 30 seconds.\n}\n</code></pre> <p>Check the whole Panda config.</p> <p>If the participant was marked as Unhealthy by the healthcheck functionality the specified number of seconds ago, it can be  automatically marked as either Removed or TurnedOff. This feature can be turned on only if the healthcheck functionality is also turned on  (so both properties <code>calls-interval</code> and <code>number-of-failures-needed-to-react</code> have to be bigger than 0).</p> <p>This functionality is not distributed across many Panda nodes and is always performed by a single one.  The failover is performed under the hood, so when the node responsible for this functionality is down or not responsive enough,  the other node will take over and take care of performing this action.</p> <p>This implemented functionality will detect only these participants that were healthy at least one time in the whole lifecycle.  This addresses the flow of having preconfigured participants. The Panda use case is to have already configured participants that will be  launched in the future or are launching at the moment - we do not want to clear them (mark them as TurnedOff/Removed) before they were ever operational.</p>"},{"location":"documentation/#routing","title":"Routing","text":""},{"location":"documentation/#how-does-the-panda-gateway-find-the-destination-route-based-on-the-request-route","title":"How does the Panda gateway find the destination route based on the request route?","text":"<p>Once the gateway gets the request, it needs to connect the request's route with one of the registered mappings if the corresponding one exists in order to pass the request further (e.g. the mapping may specify the <code>group</code> which may be your microservice).</p> <p>The panda lets you register 2 types of routes:</p> <ol> <li>Standard routes like: <code>cars/rent</code> or <code>planes/{{plane_id}}/passengers</code> where <code>plane_id</code> is a path param. </li> <li>Pocket routes like: <code>cars/supercars/**</code> where <code>**</code> means there can be anything.</li> </ol> <p>The standard routes have a higher priority than pocket routes. The pocket route will be only picked when there is no corresponding standard route.</p> <p>The routes lookups are based on the custom implementation of a Trie-like data structure which is kept in memory by every Panda node to keep the lookups very fast. The API can be found at RoutesTree.scala and the implementation at RoutesTreeImpl.scala. <code>RoutesTreeImpl#construct</code> takes a list of mappers and creates the <code>RoutesTree</code> object that contains all needed data and lets for lookups through the <code>RoutesTree#find</code> method.</p>"},{"location":"rest/","title":"Rest Documentation","text":"<p>In order to communicate with and maintain the Panda gateway, there is a REST API provided.</p>"},{"location":"rest/#gateway-entrypoint","title":"Gateway entrypoint","text":"<p>gateway/src/main/scala/com/github/pandafolks/panda/gateway/ApiGatewayRouting.scala </p> <p>All REST calls targeted against provided routes need to go through this endpoint.  Supported methods: <code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>PATCH</code>,<code>DELETE</code>.  Everything after <code>gateway</code> keyword will be resolved and dispatched to one of the routes if the match was found. There is no authorization check.  Status codes:  - 404 - if there is either no matching route found or no available participant capable to serve the request at the given time existed - everything else - comes directly from the participants' responses</p> <pre><code>gateway/...\n</code></pre>"},{"location":"rest/#healthcheck-endpoint","title":"Healthcheck endpoint","text":"<p>gateway/src/main/scala/com/github/pandafolks/panda/gateway/ApiGatewayRouting.scala </p> <p>Returns Panda Gateway instance details.  Response payload example:</p> <pre><code>{\n    \"name\": \"panda\",\n    \"version\": \"0.1.0-SNAPSHOT\",\n    \"scalaVersion\": \"2.13.8\",\n    \"sbtVersion\": \"1.4.9\",\n    \"javaVersion\": \"15.0.2+7-27\"\n}\n</code></pre> <p>Status codes:  - 200 - instance is working - 403 - the user does not have access to this resource</p> <pre><code>[GET] api/v1/healthcheck\n</code></pre>"},{"location":"rest/#authentication-endpoints","title":"Authentication endpoints","text":""},{"location":"rest/#user-management-endpoints","title":"User management endpoints.","text":"<p>user/src/main/scala/com/github/pandafolks/panda/user/AuthRouting.scala </p> <p>The endpoint is used for acquiring authentication tokens that are needed in the Panda maintaining operations like adding new participants or modifying routes.  Request payload example:</p> <pre><code>{\n  \"username\": \"admin\",\n  \"password\": \"admin\"\n} \n</code></pre> <p>Response payload example:</p> <pre><code>a6f32febacfa21aba3b00be666197b3d8d3157ff-1665825498141-c6d6680e-0a02-44ce-b58e-ffd22e3b31d5\n</code></pre> <p>How to use a Token as a Header: <code>Authorization: \"Bearer a6f32febacfa21aba3b00be666197b3d8d3157ff-1665825498141-c6d6680e-0a02-44ce-b58e-ffd22e3b31d5\"</code></p> <p>Status codes:  - 200 - the user was successfully found  - 401 - the user cannot be recognized</p> <pre><code>[POST] api/v1/auth/login\n</code></pre> <p>The endpoint is used for removing the user with provided credentials.  Request payload example:</p> <pre><code>{\n  \"username\": \"admin\",\n  \"password\": \"admin\"\n} \n</code></pre> <p>Status codes:  - 204 - the user was successfully removed  - 401 - the user cannot be recognized</p> <pre><code>[DELETE] api/v1/auth/destroy\n</code></pre> <p>The endpoint is used for creating a new user with provided credentials. The endpoint needs authentication - in other words, there needs to be passed an authentication token of the existing user. This implies that new users can be created only by existing ones.  Request payload example:</p> <pre><code>{\n  \"username\": \"admin\",\n  \"password\": \"admin\"\n} \n</code></pre> <p>Status codes:  - 201 - the user was successfully created  - 409 - the user with requested username already exists  - 400 - any error during creation occurred</p> <pre><code>[POST] api/v1/auth/register\n</code></pre>"},{"location":"rest/#participants-endpoints","title":"Participants endpoints","text":""},{"location":"rest/#endpoints-used-for-participants-serves-the-requests-are-routed-to-management-all-calls-targeting-these-endpoints-are-required-to-be-authenticated","title":"Endpoints used for participants (serves the requests are routed to) management. All calls targeting these endpoints are required to be authenticated.","text":"<p>participant/src/main/scala/com/github/pandafolks/panda/participant/ParticipantsRouting.scala </p> <p>Returns registered groups (unique types of services).  Response payload example:</p> <pre><code>[\n    {\n        \"name\": \"cars\"\n    },\n    {\n        \"name\": \"planes\"\n    }\n]\n</code></pre> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource - 404 - there isn't any registered group</p> <pre><code>[GET] api/v1/groups\n</code></pre> <p>Returns all participants (registered services). It is possible to optional filtering out results by the participants' current status. </p> <p>Response payload example:</p> <pre><code>[\n    {\n        \"host\": \"localhost\",\n        \"port\": 3000,\n        \"group\": {\n            \"name\": \"cars\"\n        },\n        \"identifier\": \"cars-one\",\n        \"healthcheckInfo\": {\n            \"path\": \"/api/v1/hb\"\n        },\n        \"status\": {\n            \"NotWorking\": {}\n        },\n        \"health\": {\n            \"Unhealthy\": {}\n        }\n    },\n    {\n        \"host\": \"localhost\",\n        \"port\": 3001,\n        \"group\": {\n            \"name\": \"cars\"\n        },\n        \"identifier\": \"cars-two\",\n        \"healthcheckInfo\": {\n            \"path\": \"api/v1/hb\"\n        },\n        \"status\": {\n            \"Working\": {}\n        },\n        \"health\": {\n            \"Unhealthy\": {}\n        }\n    },\n    {\n        \"host\": \"localhost\",\n        \"port\": 4000,\n        \"group\": {\n            \"name\": \"planes\"\n        },\n        \"identifier\": \"planes-one\",\n        \"healthcheckInfo\": {\n            \"path\": \"healthcheck\"\n        },\n        \"status\": {\n            \"Working\": {}\n        },\n        \"health\": {\n            \"Healthy\": {}\n        }\n    }\n]\n</code></pre> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource - 404 - there aren't any results</p> <pre><code>[GET] api/v1/participants?filter=[all/working/healthy]\n</code></pre> <p>Returns all participants (registered services) belonging to a specified group (unique types of services).  It is possible to optional filtering out results by the participants' current status.  Response payload example:</p> <pre><code>[\n    {\n        \"host\": \"localhost\",\n        \"port\": 3000,\n        \"group\": {\n            \"name\": \"cars\"\n        },\n        \"identifier\": \"cars-one\",\n        \"healthcheckInfo\": {\n            \"path\": \"/api/v1/hb\"\n        },\n        \"status\": {\n            \"Working\": {}\n        },\n        \"health\": {\n            \"Unhealthy\": {}\n        }\n    },\n    {\n        \"host\": \"localhost\",\n        \"port\": 3001,\n        \"group\": {\n            \"name\": \"cars\"\n        },\n        \"identifier\": \"cars-two\",\n        \"healthcheckInfo\": {\n            \"path\": \"api/v1/hb\"\n        },\n        \"status\": {\n            \"Working\": {}\n        },\n        \"health\": {\n            \"Unhealthy\": {}\n        }\n    }\n]\n</code></pre> <p>Path params:  - group_name - name of the group for which participants will be returned </p> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource - 404 - there aren't any results</p> <pre><code>[GET] api/v1/participants/{group_name}?filter=[all/working/healthy]\n</code></pre> <p>Creates new participants. The required fields are <code>host</code>, <code>port</code>, and <code>groupName</code>. The <code>identifier</code> needs to be unique across the whole application.</p> <p>Request payload example:</p> <pre><code>[\n   {\n      \"identifier\":\"cars-three\",\n      \"host\":\"localhost\",\n      \"port\":3000,\n      \"groupName\":\"cars\",\n      \"working\":true,\n      \"healthcheckRoute\":\"/api/v1/hb\"\n   },\n   {\n      \"identifier\":\"planes-one\",\n      \"host\":\"localhost\",\n      \"port\":4000,\n      \"groupName\":\"planes\",\n      \"working\":true\n   }\n]\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Created successfully 1 participants out of 2 requested\",\n    \"successfulParticipantIdentifiers\": [\n        \"cars-three\"\n    ],\n    \"errors\": [\n        \"[AlreadyExists$]: Participant with identifier \\\"planes-one\\\" already exists\"\n    ]\n}\n</code></pre> <p>Defaults (auto generated if omitted in the payload):  - identifier - <code>\"{host}-{port}-{groupName}\"</code>  - working - <code>true</code>  - healthcheckRoute - <code>\"/healthcheck\"</code> </p> <p>Status codes:  - 200 - creation request performed - 403 - the user does not have access to this resource</p> <pre><code>[POST] api/v1/participants\n</code></pre> <p>Updates participants' properties. Participant recognition is made based on the identifier. Only those properties that were contained in the payload will be updated.</p> <p>Request payload example:</p> <pre><code>[\n   {\n      \"identifier\":\"cars-three\",\n      \"host\":\"localhost\",\n      \"port\":3003,\n      \"groupName\":\"cars\",\n      \"working\":true,\n      \"healthcheckRoute\":\"/api/v1/hb\"\n   },\n   {\n      \"identifier\":\"planes-two\",\n      \"host\":\"110.110.110\"\n   }\n]\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Modified successfully 1 participants out of 2 requested\",\n    \"successfulParticipantIdentifiers\": [\n        \"cars-three\"\n    ],\n    \"errors\": [\n        \"[NotExists$]: Participant with identifier \\\"planes-two\\\" does not exist\"\n    ]\n}\n</code></pre> <p>Defaults (auto generated if omitted in the payload):  - identifier - <code>\"{host}-{port}-{groupName}\"</code> (if the participant identifier is auto generated, this is impossible to modify none of the <code>host</code>, <code>port</code>, <code>groupName</code>)</p> <p>Status codes:  - 200 - update request performed - 403 - the user does not have access to this resource</p> <pre><code>[PUT] api/v1/participants\n</code></pre> <p>Removes participants with delivered identifiers.</p> <p>Request payload example:</p> <pre><code>[\"cars-one\", \"cars-two\", \"planes-four\"]\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Removed successfully 2 participants out of 3 requested\",\n    \"successfulParticipantIdentifiers\": [\n        \"cars-one\",\n        \"cars-two\"\n    ],\n    \"errors\": [\n        \"[NotExists$]: Participant with identifier \\\"planes-four\\\" does not exist\"\n    ]\n}\n</code></pre> <p>Status codes:  - 200 - removal request performed - 403 - the user does not have access to this resource</p> <pre><code>[DELETE] api/v1/participants\n</code></pre>"},{"location":"rest/#routes-endpoints","title":"Routes endpoints","text":""},{"location":"rest/#endpoints-used-for-mappers-and-prefixes-management-all-calls-targeting-these-endpoints-are-required-to-be-authenticated","title":"Endpoints used for mappers and prefixes management. All calls targeting these endpoints are required to be authenticated.","text":"<p>routes/src/main/scala/com/github/pandafolks/panda/routes/RoutesRouting.scala </p> <p>Returns the union of all available Mappers and Prefixes. It is possible to optional filtering out results either by the  group name the Mappers belong to or by the Mappers' <code>standalone</code> property. If the Mapper is a <code>standalone</code> one that means it can be  used directly via the Gateway and in the Composition Mappers, whereas not <code>standalone</code> Mappers can be used only via Composition Mappers. </p> <p>Response payload example:</p> <pre><code>{\n    \"mappers\": [\n        [\n            \"cars/all\",\n            {\n                \"mapping\": \"cars\",\n                \"method\": \"POST\",\n                \"isStandalone\": true\n            }\n        ],\n        [\n            \"cars/supercars/**\",\n            {\n                \"mapping\": \"planes\",\n                \"method\": \"GET\",\n                \"isStandalone\": true\n            }\n        ],\n        [\n            \"planes/{{plane_id}}/passengers\",\n            {\n                \"mapping\": \"planes\",\n                \"method\": \"GET\",\n                \"isStandalone\": true\n            }\n        ],\n        [\n            \"planes/somepath1/param123\",\n            {\n                \"mapping\": \"planes\",\n                \"method\": \"GET\",\n                \"isStandalone\": false\n            }\n        ],\n        [\n            \"cars/all\",\n            {\n                \"mapping\": \"cars\",\n                \"method\": \"GET\",\n                \"isStandalone\": true\n            }\n        ],\n        [\n            \"planes/somepath1/param123\",\n            {\n                \"mapping\": \"planes\",\n                \"method\": \"DELETE\",\n                \"isStandalone\": true\n            }\n        ],\n        [\n            \"cars/rent/complex2\",\n            {\n                \"mapping\": {\n                    \"property2\": {\n                        \"property3\": \"planes/somepath1/param123\"\n                    },\n                    \"property1\": \"some/other/path\"\n                },\n                \"method\": \"GET\",\n                \"isStandalone\": true\n            }\n        ]\n    ],\n    \"prefixes\": {\n        \"cars\": \"api/v1\",\n        \"planes\": \"api/v2\"\n    }\n}\n</code></pre> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource</p> <pre><code>[GET] api/v1/routes?group=[{group_name}]&amp;standalone=[true/false]\n</code></pre> <p>Returns all available Mappers. It is possible to optional filtering out results by the <code>standalone</code> property.  If the Mapper is a <code>standalone</code> one that means it can be used directly via the Gateway and in the Composition Mappers,  whereas not <code>standalone</code> Mappers can be used only via Composition Mappers. </p> <p>Response payload example:</p> <pre><code>[\n    [\n        \"cars/all\",\n        {\n            \"mapping\": \"cars\",\n            \"method\": \"POST\",\n            \"isStandalone\": true\n        }\n    ],\n    [\n        \"cars/supercars/**\",\n        {\n            \"mapping\": \"planes\",\n            \"method\": \"GET\",\n            \"isStandalone\": true\n        }\n    ],\n    [\n        \"planes/{{plane_id}}/passengers\",\n        {\n            \"mapping\": \"planes\",\n            \"method\": \"GET\",\n            \"isStandalone\": true\n        }\n    ],\n    [\n        \"planes/somepath1/param123\",\n        {\n            \"mapping\": \"planes\",\n            \"method\": \"GET\",\n            \"isStandalone\": false\n        }\n    ],\n    [\n        \"cars/all\",\n        {\n            \"mapping\": \"cars\",\n            \"method\": \"GET\",\n            \"isStandalone\": true\n        }\n    ],\n    [\n        \"planes/somepath1/param123\",\n        {\n            \"mapping\": \"planes\",\n            \"method\": \"DELETE\",\n            \"isStandalone\": true\n        }\n    ],\n    [\n        \"cars/rent/complex2\",\n        {\n            \"mapping\": {\n                \"property2\": {\n                    \"property3\": \"planes/somepath1/param123\"\n                },\n                \"property1\": \"some/other/path\"\n            },\n            \"method\": \"GET\",\n            \"isStandalone\": true\n        }\n    ]\n]\n</code></pre> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource</p> <pre><code>[GET] api/v1/routes/mappers?standalone=[true/false]\n</code></pre> <p>Returns all available prefixes. </p> <p>Response payload example:</p> <pre><code>{\n    \"cars\": \"api/v1\",\n    \"planes\": \"api/v2\"\n}\n</code></pre> <p>Status codes:  - 200 - response successfully returned - 403 - the user does not have access to this resource</p> <pre><code>[GET] api/v1/routes/prefixes\n</code></pre> <p>Creates Mappers and Prefixes. Mappers' uniqueness is based on the combination of the Route and the HTTP Method.</p> <p>Request payload example:</p> <pre><code>{\n   \"mappers\":[\n      [\n         \"cars/supercars/**\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"GET\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"planes/{{plane_id}}/passengers\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"get\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/cars/rent/complex2\",\n         {\n            \"mapping\":{\n               \"property1\":\"some/other/path\",\n               \"property2\":{\n                  \"property3\":\"/planes/somepath1/param123\"\n               }\n            },\n            \"method\":\"GET\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/planes/somepath1/param123\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"DELETE\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/planes/somepath1/param123\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"GET\",\n            \"isStandalone\":false\n         }\n      ],\n      [\n         \"/cars/all\",\n         {\n            \"mapping\":\"cars\"\n         }\n      ],\n      [\n         \"/cars/all\",\n         {\n            \"mapping\":\"cars\",\n            \"method\":\"POST\"\n         }\n      ]\n   ],\n   \"prefixes\":{\n      \"cars\":\"api/v1\",\n      \"planes\":\"/api/v2\"\n   }\n}\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Created successfully 7 routes out of 7 requested and 2 prefixes out of 2 requested\",\n    \"successfulRoutes\": [\n        \"cars/rent/complex2\",\n        \"planes/somepath1/param123\",\n        \"planes/somepath1/param123\",\n        \"cars/all\",\n        \"cars/all\"\n    ],\n    \"successfulGroupPrefixes\": [\n        \"cars\"\n    ],\n    \"routesErrors\": [\n        \"[AlreadyExists$]: Route 'cars/supercars/**' [GET] already exists\",\n        \"[AlreadyExists$]: Route 'planes/{{plane_id}}/passengers' [GET] already exists\"\n    ],\n    \"groupPrefixesErrors\": [\n      \"[AlreadyExists$]: Group 'planes' has already defined prefix\"\n    ]\n}\n</code></pre> <p>Defaults (auto generated if omitted in the payload):  - isStandalone - <code>true</code>  - method - <code>GET</code> </p> <p>Status codes:  - 200 - creation request performed - 403 - the user does not have access to this resource</p> <pre><code>[POST] api/v1/routes\n</code></pre> <p>Updates (and creates if not exists) Mappers and Prefixes. Mappers' uniqueness is based on the combination of the Route and the HTTP Method.</p> <p>Request payload example:</p> <pre><code>{\n   \"mappers\":[\n      [\n         \"cars/supercars/**\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"GET\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"planes/{{plane_id}}/passengers\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"get\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/cars/rent/complex2\",\n         {\n            \"mapping\":{\n               \"property1\":\"some/other/path\",\n               \"property2\":{\n                  \"property3\":\"/planes/somepath1/param123\"\n               }\n            },\n            \"method\":\"GET\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/planes/somepath1/param123\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"DELETE\",\n            \"isStandalone\":true\n         }\n      ],\n      [\n         \"/planes/somepath1/param123\",\n         {\n            \"mapping\":\"planes\",\n            \"method\":\"GET\",\n            \"isStandalone\":false\n         }\n      ],\n      [\n         \"/cars/all\",\n         {\n            \"mapping\":\"cars\"\n         }\n      ],\n      [\n         \"/cars/all\",\n         {\n            \"mapping\":\"cars\",\n            \"method\":\"POST\"\n         }\n      ]\n   ],\n   \"prefixes\":{\n      \"cars\":\"api/v1\",\n      \"planes\":\"/api/v2\"\n   }\n}\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Created successfully 7 routes out of 7 requested and 2 prefixes out of 2 requested\",\n    \"successfulRoutes\": [\n        \"cars/supercars/**\",\n        \"planes/{{plane_id}}/passengers\",\n        \"cars/rent/complex2\",\n        \"planes/somepath1/param123\",\n        \"planes/somepath1/param123\",\n        \"cars/all\",\n        \"cars/all\"\n    ],\n    \"successfulGroupPrefixes\": [\n        \"cars\",\n        \"planes\"\n    ],\n    \"routesErrors\": [],\n    \"groupPrefixesErrors\": []\n}\n</code></pre> <p>Defaults (auto generated if omitted in the payload):  - isStandalone - <code>true</code>  - method - <code>GET</code> </p> <p>Status codes:  - 200 - update request performed - 403 - the user does not have access to this resource</p> <pre><code>[POST] api/v1/routes/override\n</code></pre> <p>Removes Mappers and Prefixes. Mappers' uniqueness is based on the combination of the Route and the HTTP Method.</p> <p>Request payload example:</p> <pre><code>{\n   \"mappers\":[\n      {\n         \"route\":\"/planes/somepath1/param123\",\n         \"method\":\"DELETE\"\n      },\n      {\n         \"route\":\"cars/all/\"\n      }\n   ],\n   \"prefixes\":[\n      \"planes2\",\n      \"cars23\",\n      \"cars\"\n   ]\n}\n</code></pre> <p>Response payload example:</p> <pre><code>{\n    \"message\": \"Removed successfully 2 routes out of 2 requested and 1 prefixes out of 3 requested\",\n    \"successfulRoutes\": [\n        \"planes/somepath1/param123\",\n        \"cars/all\"\n    ],\n    \"successfulGroupPrefixes\": [\n        \"cars\"\n    ],\n    \"routesErrors\": [],\n    \"groupPrefixesErrors\": [\n        \"[NotExists$]: There is no prefix associated with the group 'planes2'\",\n        \"[NotExists$]: There is no prefix associated with the group 'cars23'\"\n    ]\n}\n</code></pre> <p>Defaults (auto generated if omitted in the payload):  - method - <code>GET</code> </p> <p>Status codes:  - 200 - removal request performed - 403 - the user does not have access to this resource</p> <pre><code>[DELETE] api/v1/routes\n</code></pre>"},{"location":"system_properties/","title":"Custom System Properties","text":""},{"location":"system_properties/#pandausertokenkey","title":"panda.user.token.key","text":"<p>A private key used to sign users' authentication tokens.</p> <p>If not present, the value present in tokenKey.txt from the user's module resources is taken. If the tokenKey.txt file does not exist, the random key is generated during Panda node startup.</p> <p>It is highly required to use the same private key value across all Panda nodes.</p> <p>Example:</p> <pre><code>-Dpanda.user.token.key=5ck4kBO45606H25YUZ1f\n</code></pre>"},{"location":"system_properties/#pandaconsistenthashingstatepositionsperparticipant","title":"panda.consistent.hashing.state.positions.per.participant","text":"<p>Used only when <code>hash</code> based load balancer is used (Inside com/github/pandafolks/panda/loadbalancer/ConsistentHashingState.scala).  A number of points on the consistent hashing circle for a single participant. The higher the number is the more evenly the requests  will be spread but the performance of the adding to the circle operation will drop.</p> <p>The default value is 20.</p> <p>Example:</p> <pre><code>-Dpanda.consistent.hashing.state.positions.per.participant=30\n</code></pre>"},{"location":"system_properties/#pandaconsistenthashingstateclearemptygroupsinterval","title":"panda.consistent.hashing.state.clear.empty.groups.interval","text":"<p>Used only when <code>hash</code> based load balancer is used (Inside com/github/pandafolks/panda/loadbalancer/ConsistentHashingState.scala).  A number of hours between each run of the background job which is responsible for clearing empty groups inside the ConsistentHashingState#usedPositionsGroupedByGroup in order to reduce memory overhead. If the value is smaller or equal to '0' the background job won't be launched.</p> <p>The default value is 12.</p> <p>Example:</p> <pre><code>-Dpanda.consistent.hashing.state.clear.empty.groups.interval=24\n</code></pre>"},{"location":"system_properties/#pandamainlogfilename","title":"panda.main.log.file.name","text":"<p>The name of the main log file. The rolling policy of the main log file is SizeAndTimeBasedRollingPolicy.</p> <p>The default value is panda.</p> <p>Example:</p> <pre><code>-Dpanda.main.log.file.name=panda_logs\n</code></pre>"},{"location":"system_properties/#pandamainlogmaxfilesize","title":"panda.main.log.max.file.size","text":"<p>The size limit of the single panda log file.</p> <p>The default value is 100MB.</p> <p>Example:</p> <pre><code>-Dpanda.main.log.max.file.size=512MB\n</code></pre>"},{"location":"system_properties/#pandamainlogmaxhistoryindays","title":"panda.main.log.max.history.in.days","text":"<p>Specifies how many days the history logs of the main panda log will be kept.</p> <p>The default value is 60.</p> <p>Example:</p> <pre><code>-Dpanda.main.log.max.history.in.days=30\n</code></pre>"},{"location":"system_properties/#pandamainlogtotalsizecap","title":"panda.main.log.total.size.cap","text":"<p>Sets the size limit of the whole main panda log.</p> <p>The default value is 10GB.</p> <p>Example:</p> <pre><code>-Dpanda.main.log.total.size.cap=50GB\n</code></pre>"},{"location":"system_properties/#pandagatewaytrafficlogfilename","title":"panda.gateway.traffic.log.file.name","text":"<p>The name of the gateway traffic log file. The rolling policy of the main log file is SizeAndTimeBasedRollingPolicy.</p> <p>The default value is gateway_traffic.</p> <p>Example:</p> <pre><code>-Dpanda.gateway.traffic.log.file.name=gateway\n</code></pre>"},{"location":"system_properties/#pandagatewaytrafficlogmaxfilesize","title":"panda.gateway.traffic.log.max.file.size","text":"<p>The size limit of the single gateway traffic log file.</p> <p>The default value is 100MB.</p> <p>Example:</p> <pre><code>-Dpanda.gateway.traffic.log.max.file.size=512MB\n</code></pre>"},{"location":"system_properties/#pandagatewaytrafficlogmaxhistoryindays","title":"panda.gateway.traffic.log.max.history.in.days","text":"<p>Specifies how many days the history logs of gateway traffic log will be kept.</p> <p>The default value is 60.</p> <p>Example:</p> <pre><code>-Dpanda.gateway.traffic.log.max.history.in.days=30\n</code></pre>"},{"location":"system_properties/#pandagatewaytrafficlogtotalsizecap","title":"panda.gateway.traffic.log.total.size.cap","text":"<p>Sets the size limit of the whole gateway traffic log.</p> <p>The default value is 10GB.</p> <p>Example:</p> <pre><code>-Dpanda.gateway.traffic.log.total.size.cap=50GB\n</code></pre>"}]}